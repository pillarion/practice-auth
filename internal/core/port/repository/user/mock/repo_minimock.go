// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/pillarion/practice-auth/internal/core/port/repository/user.Repo -o repo_minimock.go -n RepoMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	model "github.com/pillarion/practice-auth/internal/core/model/user"
)

// RepoMock implements user.Repo
type RepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDelete          func(ctx context.Context, id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mRepoMockDelete

	funcInsert          func(ctx context.Context, user *model.Info) (i1 int64, err error)
	inspectFuncInsert   func(ctx context.Context, user *model.Info)
	afterInsertCounter  uint64
	beforeInsertCounter uint64
	InsertMock          mRepoMockInsert

	funcSelectByID          func(ctx context.Context, id int64) (up1 *model.User, err error)
	inspectFuncSelectByID   func(ctx context.Context, id int64)
	afterSelectByIDCounter  uint64
	beforeSelectByIDCounter uint64
	SelectByIDMock          mRepoMockSelectByID

	funcSelectByName          func(ctx context.Context, username string) (up1 *model.User, err error)
	inspectFuncSelectByName   func(ctx context.Context, username string)
	afterSelectByNameCounter  uint64
	beforeSelectByNameCounter uint64
	SelectByNameMock          mRepoMockSelectByName

	funcSelectPassword          func(ctx context.Context, username string) (s1 string, err error)
	inspectFuncSelectPassword   func(ctx context.Context, username string)
	afterSelectPasswordCounter  uint64
	beforeSelectPasswordCounter uint64
	SelectPasswordMock          mRepoMockSelectPassword

	funcUpdate          func(ctx context.Context, user *model.Info) (err error)
	inspectFuncUpdate   func(ctx context.Context, user *model.Info)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mRepoMockUpdate
}

// NewRepoMock returns a mock for user.Repo
func NewRepoMock(t minimock.Tester) *RepoMock {
	m := &RepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mRepoMockDelete{mock: m}
	m.DeleteMock.callArgs = []*RepoMockDeleteParams{}

	m.InsertMock = mRepoMockInsert{mock: m}
	m.InsertMock.callArgs = []*RepoMockInsertParams{}

	m.SelectByIDMock = mRepoMockSelectByID{mock: m}
	m.SelectByIDMock.callArgs = []*RepoMockSelectByIDParams{}

	m.SelectByNameMock = mRepoMockSelectByName{mock: m}
	m.SelectByNameMock.callArgs = []*RepoMockSelectByNameParams{}

	m.SelectPasswordMock = mRepoMockSelectPassword{mock: m}
	m.SelectPasswordMock.callArgs = []*RepoMockSelectPasswordParams{}

	m.UpdateMock = mRepoMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*RepoMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepoMockDelete struct {
	mock               *RepoMock
	defaultExpectation *RepoMockDeleteExpectation
	expectations       []*RepoMockDeleteExpectation

	callArgs []*RepoMockDeleteParams
	mutex    sync.RWMutex
}

// RepoMockDeleteExpectation specifies expectation struct of the Repo.Delete
type RepoMockDeleteExpectation struct {
	mock    *RepoMock
	params  *RepoMockDeleteParams
	results *RepoMockDeleteResults
	Counter uint64
}

// RepoMockDeleteParams contains parameters of the Repo.Delete
type RepoMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// RepoMockDeleteResults contains results of the Repo.Delete
type RepoMockDeleteResults struct {
	err error
}

// Expect sets up expected params for Repo.Delete
func (mmDelete *mRepoMockDelete) Expect(ctx context.Context, id int64) *mRepoMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepoMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RepoMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &RepoMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Repo.Delete
func (mmDelete *mRepoMockDelete) Inspect(f func(ctx context.Context, id int64)) *mRepoMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for RepoMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Repo.Delete
func (mmDelete *mRepoMockDelete) Return(err error) *RepoMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepoMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RepoMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &RepoMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the Repo.Delete method
func (mmDelete *mRepoMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *RepoMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Repo.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Repo.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Repo.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mRepoMockDelete) When(ctx context.Context, id int64) *RepoMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RepoMock.Delete mock is already set by Set")
	}

	expectation := &RepoMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &RepoMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Repo.Delete return parameters for the expectation previously defined by the When method
func (e *RepoMockDeleteExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockDeleteResults{err}
	return e.mock
}

// Delete implements user.Repo
func (mmDelete *RepoMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := RepoMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := RepoMockDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("RepoMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the RepoMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to RepoMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished RepoMock.Delete invocations
func (mmDelete *RepoMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of RepoMock.Delete invocations
func (mmDelete *RepoMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mRepoMockDelete) Calls() []*RepoMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*RepoMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *RepoMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.Delete")
		} else {
			m.t.Errorf("Expected call to RepoMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to RepoMock.Delete")
	}
}

type mRepoMockInsert struct {
	mock               *RepoMock
	defaultExpectation *RepoMockInsertExpectation
	expectations       []*RepoMockInsertExpectation

	callArgs []*RepoMockInsertParams
	mutex    sync.RWMutex
}

// RepoMockInsertExpectation specifies expectation struct of the Repo.Insert
type RepoMockInsertExpectation struct {
	mock    *RepoMock
	params  *RepoMockInsertParams
	results *RepoMockInsertResults
	Counter uint64
}

// RepoMockInsertParams contains parameters of the Repo.Insert
type RepoMockInsertParams struct {
	ctx  context.Context
	user *model.Info
}

// RepoMockInsertResults contains results of the Repo.Insert
type RepoMockInsertResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Repo.Insert
func (mmInsert *mRepoMockInsert) Expect(ctx context.Context, user *model.Info) *mRepoMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("RepoMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &RepoMockInsertExpectation{}
	}

	mmInsert.defaultExpectation.params = &RepoMockInsertParams{ctx, user}
	for _, e := range mmInsert.expectations {
		if minimock.Equal(e.params, mmInsert.defaultExpectation.params) {
			mmInsert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsert.defaultExpectation.params)
		}
	}

	return mmInsert
}

// Inspect accepts an inspector function that has same arguments as the Repo.Insert
func (mmInsert *mRepoMockInsert) Inspect(f func(ctx context.Context, user *model.Info)) *mRepoMockInsert {
	if mmInsert.mock.inspectFuncInsert != nil {
		mmInsert.mock.t.Fatalf("Inspect function is already set for RepoMock.Insert")
	}

	mmInsert.mock.inspectFuncInsert = f

	return mmInsert
}

// Return sets up results that will be returned by Repo.Insert
func (mmInsert *mRepoMockInsert) Return(i1 int64, err error) *RepoMock {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("RepoMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &RepoMockInsertExpectation{mock: mmInsert.mock}
	}
	mmInsert.defaultExpectation.results = &RepoMockInsertResults{i1, err}
	return mmInsert.mock
}

// Set uses given function f to mock the Repo.Insert method
func (mmInsert *mRepoMockInsert) Set(f func(ctx context.Context, user *model.Info) (i1 int64, err error)) *RepoMock {
	if mmInsert.defaultExpectation != nil {
		mmInsert.mock.t.Fatalf("Default expectation is already set for the Repo.Insert method")
	}

	if len(mmInsert.expectations) > 0 {
		mmInsert.mock.t.Fatalf("Some expectations are already set for the Repo.Insert method")
	}

	mmInsert.mock.funcInsert = f
	return mmInsert.mock
}

// When sets expectation for the Repo.Insert which will trigger the result defined by the following
// Then helper
func (mmInsert *mRepoMockInsert) When(ctx context.Context, user *model.Info) *RepoMockInsertExpectation {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("RepoMock.Insert mock is already set by Set")
	}

	expectation := &RepoMockInsertExpectation{
		mock:   mmInsert.mock,
		params: &RepoMockInsertParams{ctx, user},
	}
	mmInsert.expectations = append(mmInsert.expectations, expectation)
	return expectation
}

// Then sets up Repo.Insert return parameters for the expectation previously defined by the When method
func (e *RepoMockInsertExpectation) Then(i1 int64, err error) *RepoMock {
	e.results = &RepoMockInsertResults{i1, err}
	return e.mock
}

// Insert implements user.Repo
func (mmInsert *RepoMock) Insert(ctx context.Context, user *model.Info) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmInsert.beforeInsertCounter, 1)
	defer mm_atomic.AddUint64(&mmInsert.afterInsertCounter, 1)

	if mmInsert.inspectFuncInsert != nil {
		mmInsert.inspectFuncInsert(ctx, user)
	}

	mm_params := RepoMockInsertParams{ctx, user}

	// Record call args
	mmInsert.InsertMock.mutex.Lock()
	mmInsert.InsertMock.callArgs = append(mmInsert.InsertMock.callArgs, &mm_params)
	mmInsert.InsertMock.mutex.Unlock()

	for _, e := range mmInsert.InsertMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsert.InsertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsert.InsertMock.defaultExpectation.Counter, 1)
		mm_want := mmInsert.InsertMock.defaultExpectation.params
		mm_got := RepoMockInsertParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsert.t.Errorf("RepoMock.Insert got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsert.InsertMock.defaultExpectation.results
		if mm_results == nil {
			mmInsert.t.Fatal("No results are set for the RepoMock.Insert")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmInsert.funcInsert != nil {
		return mmInsert.funcInsert(ctx, user)
	}
	mmInsert.t.Fatalf("Unexpected call to RepoMock.Insert. %v %v", ctx, user)
	return
}

// InsertAfterCounter returns a count of finished RepoMock.Insert invocations
func (mmInsert *RepoMock) InsertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.afterInsertCounter)
}

// InsertBeforeCounter returns a count of RepoMock.Insert invocations
func (mmInsert *RepoMock) InsertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.beforeInsertCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.Insert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsert *mRepoMockInsert) Calls() []*RepoMockInsertParams {
	mmInsert.mutex.RLock()

	argCopy := make([]*RepoMockInsertParams, len(mmInsert.callArgs))
	copy(argCopy, mmInsert.callArgs)

	mmInsert.mutex.RUnlock()

	return argCopy
}

// MinimockInsertDone returns true if the count of the Insert invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockInsertDone() bool {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertInspect logs each unmet expectation
func (m *RepoMock) MinimockInsertInspect() {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.Insert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		if m.InsertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.Insert")
		} else {
			m.t.Errorf("Expected call to RepoMock.Insert with params: %#v", *m.InsertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		m.t.Error("Expected call to RepoMock.Insert")
	}
}

type mRepoMockSelectByID struct {
	mock               *RepoMock
	defaultExpectation *RepoMockSelectByIDExpectation
	expectations       []*RepoMockSelectByIDExpectation

	callArgs []*RepoMockSelectByIDParams
	mutex    sync.RWMutex
}

// RepoMockSelectByIDExpectation specifies expectation struct of the Repo.SelectByID
type RepoMockSelectByIDExpectation struct {
	mock    *RepoMock
	params  *RepoMockSelectByIDParams
	results *RepoMockSelectByIDResults
	Counter uint64
}

// RepoMockSelectByIDParams contains parameters of the Repo.SelectByID
type RepoMockSelectByIDParams struct {
	ctx context.Context
	id  int64
}

// RepoMockSelectByIDResults contains results of the Repo.SelectByID
type RepoMockSelectByIDResults struct {
	up1 *model.User
	err error
}

// Expect sets up expected params for Repo.SelectByID
func (mmSelectByID *mRepoMockSelectByID) Expect(ctx context.Context, id int64) *mRepoMockSelectByID {
	if mmSelectByID.mock.funcSelectByID != nil {
		mmSelectByID.mock.t.Fatalf("RepoMock.SelectByID mock is already set by Set")
	}

	if mmSelectByID.defaultExpectation == nil {
		mmSelectByID.defaultExpectation = &RepoMockSelectByIDExpectation{}
	}

	mmSelectByID.defaultExpectation.params = &RepoMockSelectByIDParams{ctx, id}
	for _, e := range mmSelectByID.expectations {
		if minimock.Equal(e.params, mmSelectByID.defaultExpectation.params) {
			mmSelectByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectByID.defaultExpectation.params)
		}
	}

	return mmSelectByID
}

// Inspect accepts an inspector function that has same arguments as the Repo.SelectByID
func (mmSelectByID *mRepoMockSelectByID) Inspect(f func(ctx context.Context, id int64)) *mRepoMockSelectByID {
	if mmSelectByID.mock.inspectFuncSelectByID != nil {
		mmSelectByID.mock.t.Fatalf("Inspect function is already set for RepoMock.SelectByID")
	}

	mmSelectByID.mock.inspectFuncSelectByID = f

	return mmSelectByID
}

// Return sets up results that will be returned by Repo.SelectByID
func (mmSelectByID *mRepoMockSelectByID) Return(up1 *model.User, err error) *RepoMock {
	if mmSelectByID.mock.funcSelectByID != nil {
		mmSelectByID.mock.t.Fatalf("RepoMock.SelectByID mock is already set by Set")
	}

	if mmSelectByID.defaultExpectation == nil {
		mmSelectByID.defaultExpectation = &RepoMockSelectByIDExpectation{mock: mmSelectByID.mock}
	}
	mmSelectByID.defaultExpectation.results = &RepoMockSelectByIDResults{up1, err}
	return mmSelectByID.mock
}

// Set uses given function f to mock the Repo.SelectByID method
func (mmSelectByID *mRepoMockSelectByID) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *RepoMock {
	if mmSelectByID.defaultExpectation != nil {
		mmSelectByID.mock.t.Fatalf("Default expectation is already set for the Repo.SelectByID method")
	}

	if len(mmSelectByID.expectations) > 0 {
		mmSelectByID.mock.t.Fatalf("Some expectations are already set for the Repo.SelectByID method")
	}

	mmSelectByID.mock.funcSelectByID = f
	return mmSelectByID.mock
}

// When sets expectation for the Repo.SelectByID which will trigger the result defined by the following
// Then helper
func (mmSelectByID *mRepoMockSelectByID) When(ctx context.Context, id int64) *RepoMockSelectByIDExpectation {
	if mmSelectByID.mock.funcSelectByID != nil {
		mmSelectByID.mock.t.Fatalf("RepoMock.SelectByID mock is already set by Set")
	}

	expectation := &RepoMockSelectByIDExpectation{
		mock:   mmSelectByID.mock,
		params: &RepoMockSelectByIDParams{ctx, id},
	}
	mmSelectByID.expectations = append(mmSelectByID.expectations, expectation)
	return expectation
}

// Then sets up Repo.SelectByID return parameters for the expectation previously defined by the When method
func (e *RepoMockSelectByIDExpectation) Then(up1 *model.User, err error) *RepoMock {
	e.results = &RepoMockSelectByIDResults{up1, err}
	return e.mock
}

// SelectByID implements user.Repo
func (mmSelectByID *RepoMock) SelectByID(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmSelectByID.beforeSelectByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectByID.afterSelectByIDCounter, 1)

	if mmSelectByID.inspectFuncSelectByID != nil {
		mmSelectByID.inspectFuncSelectByID(ctx, id)
	}

	mm_params := RepoMockSelectByIDParams{ctx, id}

	// Record call args
	mmSelectByID.SelectByIDMock.mutex.Lock()
	mmSelectByID.SelectByIDMock.callArgs = append(mmSelectByID.SelectByIDMock.callArgs, &mm_params)
	mmSelectByID.SelectByIDMock.mutex.Unlock()

	for _, e := range mmSelectByID.SelectByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmSelectByID.SelectByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectByID.SelectByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectByID.SelectByIDMock.defaultExpectation.params
		mm_got := RepoMockSelectByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectByID.t.Errorf("RepoMock.SelectByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectByID.SelectByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectByID.t.Fatal("No results are set for the RepoMock.SelectByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmSelectByID.funcSelectByID != nil {
		return mmSelectByID.funcSelectByID(ctx, id)
	}
	mmSelectByID.t.Fatalf("Unexpected call to RepoMock.SelectByID. %v %v", ctx, id)
	return
}

// SelectByIDAfterCounter returns a count of finished RepoMock.SelectByID invocations
func (mmSelectByID *RepoMock) SelectByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectByID.afterSelectByIDCounter)
}

// SelectByIDBeforeCounter returns a count of RepoMock.SelectByID invocations
func (mmSelectByID *RepoMock) SelectByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectByID.beforeSelectByIDCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.SelectByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectByID *mRepoMockSelectByID) Calls() []*RepoMockSelectByIDParams {
	mmSelectByID.mutex.RLock()

	argCopy := make([]*RepoMockSelectByIDParams, len(mmSelectByID.callArgs))
	copy(argCopy, mmSelectByID.callArgs)

	mmSelectByID.mutex.RUnlock()

	return argCopy
}

// MinimockSelectByIDDone returns true if the count of the SelectByID invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockSelectByIDDone() bool {
	for _, e := range m.SelectByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectByID != nil && mm_atomic.LoadUint64(&m.afterSelectByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelectByIDInspect logs each unmet expectation
func (m *RepoMock) MinimockSelectByIDInspect() {
	for _, e := range m.SelectByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.SelectByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectByIDCounter) < 1 {
		if m.SelectByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.SelectByID")
		} else {
			m.t.Errorf("Expected call to RepoMock.SelectByID with params: %#v", *m.SelectByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectByID != nil && mm_atomic.LoadUint64(&m.afterSelectByIDCounter) < 1 {
		m.t.Error("Expected call to RepoMock.SelectByID")
	}
}

type mRepoMockSelectByName struct {
	mock               *RepoMock
	defaultExpectation *RepoMockSelectByNameExpectation
	expectations       []*RepoMockSelectByNameExpectation

	callArgs []*RepoMockSelectByNameParams
	mutex    sync.RWMutex
}

// RepoMockSelectByNameExpectation specifies expectation struct of the Repo.SelectByName
type RepoMockSelectByNameExpectation struct {
	mock    *RepoMock
	params  *RepoMockSelectByNameParams
	results *RepoMockSelectByNameResults
	Counter uint64
}

// RepoMockSelectByNameParams contains parameters of the Repo.SelectByName
type RepoMockSelectByNameParams struct {
	ctx      context.Context
	username string
}

// RepoMockSelectByNameResults contains results of the Repo.SelectByName
type RepoMockSelectByNameResults struct {
	up1 *model.User
	err error
}

// Expect sets up expected params for Repo.SelectByName
func (mmSelectByName *mRepoMockSelectByName) Expect(ctx context.Context, username string) *mRepoMockSelectByName {
	if mmSelectByName.mock.funcSelectByName != nil {
		mmSelectByName.mock.t.Fatalf("RepoMock.SelectByName mock is already set by Set")
	}

	if mmSelectByName.defaultExpectation == nil {
		mmSelectByName.defaultExpectation = &RepoMockSelectByNameExpectation{}
	}

	mmSelectByName.defaultExpectation.params = &RepoMockSelectByNameParams{ctx, username}
	for _, e := range mmSelectByName.expectations {
		if minimock.Equal(e.params, mmSelectByName.defaultExpectation.params) {
			mmSelectByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectByName.defaultExpectation.params)
		}
	}

	return mmSelectByName
}

// Inspect accepts an inspector function that has same arguments as the Repo.SelectByName
func (mmSelectByName *mRepoMockSelectByName) Inspect(f func(ctx context.Context, username string)) *mRepoMockSelectByName {
	if mmSelectByName.mock.inspectFuncSelectByName != nil {
		mmSelectByName.mock.t.Fatalf("Inspect function is already set for RepoMock.SelectByName")
	}

	mmSelectByName.mock.inspectFuncSelectByName = f

	return mmSelectByName
}

// Return sets up results that will be returned by Repo.SelectByName
func (mmSelectByName *mRepoMockSelectByName) Return(up1 *model.User, err error) *RepoMock {
	if mmSelectByName.mock.funcSelectByName != nil {
		mmSelectByName.mock.t.Fatalf("RepoMock.SelectByName mock is already set by Set")
	}

	if mmSelectByName.defaultExpectation == nil {
		mmSelectByName.defaultExpectation = &RepoMockSelectByNameExpectation{mock: mmSelectByName.mock}
	}
	mmSelectByName.defaultExpectation.results = &RepoMockSelectByNameResults{up1, err}
	return mmSelectByName.mock
}

// Set uses given function f to mock the Repo.SelectByName method
func (mmSelectByName *mRepoMockSelectByName) Set(f func(ctx context.Context, username string) (up1 *model.User, err error)) *RepoMock {
	if mmSelectByName.defaultExpectation != nil {
		mmSelectByName.mock.t.Fatalf("Default expectation is already set for the Repo.SelectByName method")
	}

	if len(mmSelectByName.expectations) > 0 {
		mmSelectByName.mock.t.Fatalf("Some expectations are already set for the Repo.SelectByName method")
	}

	mmSelectByName.mock.funcSelectByName = f
	return mmSelectByName.mock
}

// When sets expectation for the Repo.SelectByName which will trigger the result defined by the following
// Then helper
func (mmSelectByName *mRepoMockSelectByName) When(ctx context.Context, username string) *RepoMockSelectByNameExpectation {
	if mmSelectByName.mock.funcSelectByName != nil {
		mmSelectByName.mock.t.Fatalf("RepoMock.SelectByName mock is already set by Set")
	}

	expectation := &RepoMockSelectByNameExpectation{
		mock:   mmSelectByName.mock,
		params: &RepoMockSelectByNameParams{ctx, username},
	}
	mmSelectByName.expectations = append(mmSelectByName.expectations, expectation)
	return expectation
}

// Then sets up Repo.SelectByName return parameters for the expectation previously defined by the When method
func (e *RepoMockSelectByNameExpectation) Then(up1 *model.User, err error) *RepoMock {
	e.results = &RepoMockSelectByNameResults{up1, err}
	return e.mock
}

// SelectByName implements user.Repo
func (mmSelectByName *RepoMock) SelectByName(ctx context.Context, username string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmSelectByName.beforeSelectByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectByName.afterSelectByNameCounter, 1)

	if mmSelectByName.inspectFuncSelectByName != nil {
		mmSelectByName.inspectFuncSelectByName(ctx, username)
	}

	mm_params := RepoMockSelectByNameParams{ctx, username}

	// Record call args
	mmSelectByName.SelectByNameMock.mutex.Lock()
	mmSelectByName.SelectByNameMock.callArgs = append(mmSelectByName.SelectByNameMock.callArgs, &mm_params)
	mmSelectByName.SelectByNameMock.mutex.Unlock()

	for _, e := range mmSelectByName.SelectByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmSelectByName.SelectByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectByName.SelectByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectByName.SelectByNameMock.defaultExpectation.params
		mm_got := RepoMockSelectByNameParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectByName.t.Errorf("RepoMock.SelectByName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectByName.SelectByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectByName.t.Fatal("No results are set for the RepoMock.SelectByName")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmSelectByName.funcSelectByName != nil {
		return mmSelectByName.funcSelectByName(ctx, username)
	}
	mmSelectByName.t.Fatalf("Unexpected call to RepoMock.SelectByName. %v %v", ctx, username)
	return
}

// SelectByNameAfterCounter returns a count of finished RepoMock.SelectByName invocations
func (mmSelectByName *RepoMock) SelectByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectByName.afterSelectByNameCounter)
}

// SelectByNameBeforeCounter returns a count of RepoMock.SelectByName invocations
func (mmSelectByName *RepoMock) SelectByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectByName.beforeSelectByNameCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.SelectByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectByName *mRepoMockSelectByName) Calls() []*RepoMockSelectByNameParams {
	mmSelectByName.mutex.RLock()

	argCopy := make([]*RepoMockSelectByNameParams, len(mmSelectByName.callArgs))
	copy(argCopy, mmSelectByName.callArgs)

	mmSelectByName.mutex.RUnlock()

	return argCopy
}

// MinimockSelectByNameDone returns true if the count of the SelectByName invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockSelectByNameDone() bool {
	for _, e := range m.SelectByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectByNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectByName != nil && mm_atomic.LoadUint64(&m.afterSelectByNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelectByNameInspect logs each unmet expectation
func (m *RepoMock) MinimockSelectByNameInspect() {
	for _, e := range m.SelectByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.SelectByName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectByNameCounter) < 1 {
		if m.SelectByNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.SelectByName")
		} else {
			m.t.Errorf("Expected call to RepoMock.SelectByName with params: %#v", *m.SelectByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectByName != nil && mm_atomic.LoadUint64(&m.afterSelectByNameCounter) < 1 {
		m.t.Error("Expected call to RepoMock.SelectByName")
	}
}

type mRepoMockSelectPassword struct {
	mock               *RepoMock
	defaultExpectation *RepoMockSelectPasswordExpectation
	expectations       []*RepoMockSelectPasswordExpectation

	callArgs []*RepoMockSelectPasswordParams
	mutex    sync.RWMutex
}

// RepoMockSelectPasswordExpectation specifies expectation struct of the Repo.SelectPassword
type RepoMockSelectPasswordExpectation struct {
	mock    *RepoMock
	params  *RepoMockSelectPasswordParams
	results *RepoMockSelectPasswordResults
	Counter uint64
}

// RepoMockSelectPasswordParams contains parameters of the Repo.SelectPassword
type RepoMockSelectPasswordParams struct {
	ctx      context.Context
	username string
}

// RepoMockSelectPasswordResults contains results of the Repo.SelectPassword
type RepoMockSelectPasswordResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Repo.SelectPassword
func (mmSelectPassword *mRepoMockSelectPassword) Expect(ctx context.Context, username string) *mRepoMockSelectPassword {
	if mmSelectPassword.mock.funcSelectPassword != nil {
		mmSelectPassword.mock.t.Fatalf("RepoMock.SelectPassword mock is already set by Set")
	}

	if mmSelectPassword.defaultExpectation == nil {
		mmSelectPassword.defaultExpectation = &RepoMockSelectPasswordExpectation{}
	}

	mmSelectPassword.defaultExpectation.params = &RepoMockSelectPasswordParams{ctx, username}
	for _, e := range mmSelectPassword.expectations {
		if minimock.Equal(e.params, mmSelectPassword.defaultExpectation.params) {
			mmSelectPassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectPassword.defaultExpectation.params)
		}
	}

	return mmSelectPassword
}

// Inspect accepts an inspector function that has same arguments as the Repo.SelectPassword
func (mmSelectPassword *mRepoMockSelectPassword) Inspect(f func(ctx context.Context, username string)) *mRepoMockSelectPassword {
	if mmSelectPassword.mock.inspectFuncSelectPassword != nil {
		mmSelectPassword.mock.t.Fatalf("Inspect function is already set for RepoMock.SelectPassword")
	}

	mmSelectPassword.mock.inspectFuncSelectPassword = f

	return mmSelectPassword
}

// Return sets up results that will be returned by Repo.SelectPassword
func (mmSelectPassword *mRepoMockSelectPassword) Return(s1 string, err error) *RepoMock {
	if mmSelectPassword.mock.funcSelectPassword != nil {
		mmSelectPassword.mock.t.Fatalf("RepoMock.SelectPassword mock is already set by Set")
	}

	if mmSelectPassword.defaultExpectation == nil {
		mmSelectPassword.defaultExpectation = &RepoMockSelectPasswordExpectation{mock: mmSelectPassword.mock}
	}
	mmSelectPassword.defaultExpectation.results = &RepoMockSelectPasswordResults{s1, err}
	return mmSelectPassword.mock
}

// Set uses given function f to mock the Repo.SelectPassword method
func (mmSelectPassword *mRepoMockSelectPassword) Set(f func(ctx context.Context, username string) (s1 string, err error)) *RepoMock {
	if mmSelectPassword.defaultExpectation != nil {
		mmSelectPassword.mock.t.Fatalf("Default expectation is already set for the Repo.SelectPassword method")
	}

	if len(mmSelectPassword.expectations) > 0 {
		mmSelectPassword.mock.t.Fatalf("Some expectations are already set for the Repo.SelectPassword method")
	}

	mmSelectPassword.mock.funcSelectPassword = f
	return mmSelectPassword.mock
}

// When sets expectation for the Repo.SelectPassword which will trigger the result defined by the following
// Then helper
func (mmSelectPassword *mRepoMockSelectPassword) When(ctx context.Context, username string) *RepoMockSelectPasswordExpectation {
	if mmSelectPassword.mock.funcSelectPassword != nil {
		mmSelectPassword.mock.t.Fatalf("RepoMock.SelectPassword mock is already set by Set")
	}

	expectation := &RepoMockSelectPasswordExpectation{
		mock:   mmSelectPassword.mock,
		params: &RepoMockSelectPasswordParams{ctx, username},
	}
	mmSelectPassword.expectations = append(mmSelectPassword.expectations, expectation)
	return expectation
}

// Then sets up Repo.SelectPassword return parameters for the expectation previously defined by the When method
func (e *RepoMockSelectPasswordExpectation) Then(s1 string, err error) *RepoMock {
	e.results = &RepoMockSelectPasswordResults{s1, err}
	return e.mock
}

// SelectPassword implements user.Repo
func (mmSelectPassword *RepoMock) SelectPassword(ctx context.Context, username string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSelectPassword.beforeSelectPasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectPassword.afterSelectPasswordCounter, 1)

	if mmSelectPassword.inspectFuncSelectPassword != nil {
		mmSelectPassword.inspectFuncSelectPassword(ctx, username)
	}

	mm_params := RepoMockSelectPasswordParams{ctx, username}

	// Record call args
	mmSelectPassword.SelectPasswordMock.mutex.Lock()
	mmSelectPassword.SelectPasswordMock.callArgs = append(mmSelectPassword.SelectPasswordMock.callArgs, &mm_params)
	mmSelectPassword.SelectPasswordMock.mutex.Unlock()

	for _, e := range mmSelectPassword.SelectPasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSelectPassword.SelectPasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectPassword.SelectPasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectPassword.SelectPasswordMock.defaultExpectation.params
		mm_got := RepoMockSelectPasswordParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectPassword.t.Errorf("RepoMock.SelectPassword got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectPassword.SelectPasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectPassword.t.Fatal("No results are set for the RepoMock.SelectPassword")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSelectPassword.funcSelectPassword != nil {
		return mmSelectPassword.funcSelectPassword(ctx, username)
	}
	mmSelectPassword.t.Fatalf("Unexpected call to RepoMock.SelectPassword. %v %v", ctx, username)
	return
}

// SelectPasswordAfterCounter returns a count of finished RepoMock.SelectPassword invocations
func (mmSelectPassword *RepoMock) SelectPasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectPassword.afterSelectPasswordCounter)
}

// SelectPasswordBeforeCounter returns a count of RepoMock.SelectPassword invocations
func (mmSelectPassword *RepoMock) SelectPasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectPassword.beforeSelectPasswordCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.SelectPassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectPassword *mRepoMockSelectPassword) Calls() []*RepoMockSelectPasswordParams {
	mmSelectPassword.mutex.RLock()

	argCopy := make([]*RepoMockSelectPasswordParams, len(mmSelectPassword.callArgs))
	copy(argCopy, mmSelectPassword.callArgs)

	mmSelectPassword.mutex.RUnlock()

	return argCopy
}

// MinimockSelectPasswordDone returns true if the count of the SelectPassword invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockSelectPasswordDone() bool {
	for _, e := range m.SelectPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectPasswordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectPasswordCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectPassword != nil && mm_atomic.LoadUint64(&m.afterSelectPasswordCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelectPasswordInspect logs each unmet expectation
func (m *RepoMock) MinimockSelectPasswordInspect() {
	for _, e := range m.SelectPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.SelectPassword with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectPasswordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectPasswordCounter) < 1 {
		if m.SelectPasswordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.SelectPassword")
		} else {
			m.t.Errorf("Expected call to RepoMock.SelectPassword with params: %#v", *m.SelectPasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectPassword != nil && mm_atomic.LoadUint64(&m.afterSelectPasswordCounter) < 1 {
		m.t.Error("Expected call to RepoMock.SelectPassword")
	}
}

type mRepoMockUpdate struct {
	mock               *RepoMock
	defaultExpectation *RepoMockUpdateExpectation
	expectations       []*RepoMockUpdateExpectation

	callArgs []*RepoMockUpdateParams
	mutex    sync.RWMutex
}

// RepoMockUpdateExpectation specifies expectation struct of the Repo.Update
type RepoMockUpdateExpectation struct {
	mock    *RepoMock
	params  *RepoMockUpdateParams
	results *RepoMockUpdateResults
	Counter uint64
}

// RepoMockUpdateParams contains parameters of the Repo.Update
type RepoMockUpdateParams struct {
	ctx  context.Context
	user *model.Info
}

// RepoMockUpdateResults contains results of the Repo.Update
type RepoMockUpdateResults struct {
	err error
}

// Expect sets up expected params for Repo.Update
func (mmUpdate *mRepoMockUpdate) Expect(ctx context.Context, user *model.Info) *mRepoMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepoMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepoMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &RepoMockUpdateParams{ctx, user}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Repo.Update
func (mmUpdate *mRepoMockUpdate) Inspect(f func(ctx context.Context, user *model.Info)) *mRepoMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for RepoMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Repo.Update
func (mmUpdate *mRepoMockUpdate) Return(err error) *RepoMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepoMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepoMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &RepoMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the Repo.Update method
func (mmUpdate *mRepoMockUpdate) Set(f func(ctx context.Context, user *model.Info) (err error)) *RepoMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Repo.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Repo.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Repo.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mRepoMockUpdate) When(ctx context.Context, user *model.Info) *RepoMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepoMock.Update mock is already set by Set")
	}

	expectation := &RepoMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &RepoMockUpdateParams{ctx, user},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Repo.Update return parameters for the expectation previously defined by the When method
func (e *RepoMockUpdateExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockUpdateResults{err}
	return e.mock
}

// Update implements user.Repo
func (mmUpdate *RepoMock) Update(ctx context.Context, user *model.Info) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, user)
	}

	mm_params := RepoMockUpdateParams{ctx, user}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := RepoMockUpdateParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("RepoMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the RepoMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, user)
	}
	mmUpdate.t.Fatalf("Unexpected call to RepoMock.Update. %v %v", ctx, user)
	return
}

// UpdateAfterCounter returns a count of finished RepoMock.Update invocations
func (mmUpdate *RepoMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of RepoMock.Update invocations
func (mmUpdate *RepoMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mRepoMockUpdate) Calls() []*RepoMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*RepoMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *RepoMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.Update")
		} else {
			m.t.Errorf("Expected call to RepoMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to RepoMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteInspect()

			m.MinimockInsertInspect()

			m.MinimockSelectByIDInspect()

			m.MinimockSelectByNameInspect()

			m.MinimockSelectPasswordInspect()

			m.MinimockUpdateInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockInsertDone() &&
		m.MinimockSelectByIDDone() &&
		m.MinimockSelectByNameDone() &&
		m.MinimockSelectPasswordDone() &&
		m.MinimockUpdateDone()
}
